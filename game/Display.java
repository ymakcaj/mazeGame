package main.game;

import main.GameObjects.Key;
import main.GameObjects.Player;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

import static main.MazeGenerator.*;

/**
 * as per kphilemon's (https://github.com/kphilemon/maze-runner.git)
 * app, this is a class encapsulating all the methods required for 
 * printing in the console.
 */

class Display {

    private static final char FOG = '#';
    private final char[][] map;
    private final Player player;
    private final int height;
    private final int width;

    /*
     * @param map - 2d char array making up the maze
     * @param player - the Player object
     */

    Display(char[][] map, Player player) {
        this.map = map;
        this.height = map.length;
        this.width = map[0].length;
        this.player = player;
    }

    /**
     * Updates the game map and game stats to be printed on the console (to one
     * of the two positve types of game map)
     * 
     * If Game#isVisibilityMode is true, a partially-covered game map generated by
     * #createCoveredMap() will be printed on the console,
     * else a fully visible game map which is not covered will be printed instead.
     * 
     * Note: this method is meant to be invoked in LevelOne because keys will only appear in level one.
     *
     * @param keys the arrayList of keys to be collected in LevelOne
     */

    void update(ArrayList<Key> keys) {
        clearScreen();
        char[][] displayMap = (Game.isVisibilityMode) ? createCoveredMap():map;

        for (int row=0; row < displayMap.length; row++) {
            System.out.print(new String(displayMap[row]));
            switch (row) {
                case 2:
                    System.out.printf("\tKey(s) collected %d/%d\n", LevelOne.NUMBER_OF_KEYS - keys.size(), LevelOne.NUMBER_OF_KEYS);
                    break;
                case 4:
                    System.out.printf("\tHint to the nearest Key: %s\n", getNearestKeyHints(keys));
                    break;
                case 6:
                    System.out.printf("\tVisibility: %d blocks\n", player.getVisibility());
                    break;
                case 8:
                    System.out.printf("\tHealth: %d/%d\n", (player.isDead()) ? 0 : player.getHealthLevel(), Player.INITIAL_HEALTH_LEVEL);
                    break;
                default:
                    System.out.println();
            }
        }
    }

    /**
     * Returns a 2D array of characters representing the partially-covered game map.
     * This method first create a fully-covered game map, then it uncovers the player
     * and the rest game map based on the player's visibility.
     *
     * @return a partially-covered game map
     */

    private char[][] createCoveredMap() {
        char[][] coveredMap = new char[height][width];

        // firstly, cover the map w/ @FOG
    }
}